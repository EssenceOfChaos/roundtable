defmodule RoundtableTest.Router do
  use ExUnit.Case, async: true

  # "setup_all" is called once per module before any test runs
  setup_all do
    IO.puts("Starting AssertionTest")

    # Context is not updated here
    :ok
  end

  # This makes the conn object avaiable in the scope of the tests,
  # which can be used to make the HTTP request
  # https://hexdocs.pm/plug/Plug.Test.html
  use Plug.Test

  # We call the Plug init/1 function with the options then store
  # returned options in a Module attribute opts.
  # Note: @ is module attribute unary operator
  # https://hexdocs.pm/elixir/main/Kernel.html#@/1
  # https://hexdocs.pm/plug/Plug.html#c:init/1
  @opts Roundtable.Router.init([])

  # Create a test with the name "return ok"
  test "return ok" do
    # Build a connection which is GET request on / url
    conn = conn(:get, "/")

    # Then call Plug.call/2 with the connection and options
    # https://hexdocs.pm/plug/Plug.html#c:call/2
    conn = Roundtable.Router.call(conn, @opts)

    # Finally we are using the assert/2 function to check for the
    # correctness of the response
    # https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#assert/2
    assert conn.state == :sent
    assert conn.status == 200
    assert conn.resp_body == "Roundtable Index Route"
  end

  describe "posts" do
    # The setup callback is called before each test executes and the on_exit after each test is complete
    # We will use this hook to list all the mongo db collections and for each of
    # the collection to clear out the entire collection. This way for every test
    # case we will start from a clean slate
    setup do
      on_exit(fn ->
        Mongo.show_collections(:mongo)
        |> Enum.each(fn col -> Mongo.delete_many!(:mongo, col, %{}) end)
      end)
    end

    test "POST /post should return ok" do
      # Assert that there are no elements in the db
      assert Mongo.find(:mongo, "posts", %{}) |> Enum.count() == 0

      # Make an API to call create a post
      conn =
        conn(:post, "/post", %{
          user: 1,
          title: "Test Title",
          description: "Test description",
          body: "Test body",
          tags: ["test"],
          upvoted: 0,
          downvoted: 0,
          imagePreview: "link-goes-here",
          image: "link-goes-here"
        })

      conn = Roundtable.Router.call(conn, @opts)

      # Checking that request was actually sent
      assert conn.state == :sent

      # Checking that response code was 200
      assert conn.status == 200

      # Asserting that response body was what we expected
      # Note: We are using pattern matching here to perform the assertion
      # The id is autogenerated by mongodb so we have not way of predicting it
      # therefore we just use _ to match to anything but expect it to exist
      assert %{
               "user" => 1,
               "title" => "Test Title",
               "description" => "Test description",
               "body" => "Test body",
               "tags" => ["test"],
               "upvoted" => 0,
               "downvoted" => 0,
               "imagePreview" => "link-goes-here",
               "image" => "link-goes-here"
             } = Jason.decode!(conn.resp_body)

      # Assert that there is something in the db
      assert Mongo.find(:mongo, "posts", %{}) |> Enum.count() == 1
    end

    # A simple helper function that will help up quickly create
    # two posts in the databse
    defp createPosts() do
      result =
        Mongo.insert_many!(:mongo, "posts", [
          %{user: 1, title: "Post 1", body: "Content 1"},
          %{user: 2, title: "Post 2", body: "Content 2"}
        ])

      # The ids are BSON ObjectId which we are encoding to string for easier consumption
      result.inserted_ids |> Enum.map(fn id -> BSON.ObjectId.encode!(id) end)
    end

    test "GET /posts should fetch all the posts" do
      createPosts()

      conn = conn(:get, "/posts")
      conn = Roundtable.Router.call(conn, @opts)

      assert conn.state == :sent
      assert conn.status == 200

      resp = Jason.decode!(conn.resp_body)

      assert Enum.count(resp) == 2

      assert %{
               "user" => 1,
               "body" => "Content 1",
               "title" => "Post 1"
             } = Enum.at(resp, 0)

      assert %{
               "user" => 2,
               "body" => "Content 2",
               "title" => "Post 2"
             } = Enum.at(resp, 1)
    end

    test "GET /post/:id should fetch a single post" do
      # using pattern matching to get the first id
      [id | _] = createPosts()

      # string interpolation
      conn = conn(:get, "/post/#{id}")
      conn = Roundtable.Router.call(conn, @opts)

      assert conn.state == :sent
      assert conn.status == 200

      assert %{
               "user" => 1,
               "body" => "Content 1",
               "title" => "Post 1"
             } = Jason.decode!(conn.resp_body)
    end

    test "PUT /post/:id should update a post" do
      [id | _] = createPosts()

      conn = conn(:put, "/post/#{id}", %{body: "Updated Body 3"})
      conn = Roundtable.Router.call(conn, @opts)

      assert conn.state == :sent
      assert conn.status == 200

      assert %{
               "user" => 1,
               "body" => "Updated Body 3",
               "title" => "Post 1"
             } = Jason.decode!(conn.resp_body)
    end

    test "DELETE /post/:id should delete a post" do
      [id | _] = createPosts()

      assert Mongo.find(:mongo, "posts", %{}) |> Enum.count() == 2

      conn = conn(:delete, "/post/#{id}", %{body: "Updated Body 3"})
      conn = Roundtable.Router.call(conn, @opts)

      assert conn.state == :sent
      assert conn.status == 200

      assert Mongo.find(:mongo, "posts", %{}) |> Enum.count() == 1
    end
  end
end
